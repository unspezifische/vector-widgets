<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Vector Databases — Final Quiz</title>
<style>
  :root{
    --bg:#0b1020; --fg:#e8ecf2; --muted:#9aa7bd; --accent:#8fd3ff; --line:#223252; --card:#141b2f; --good:#22c55e; --warn:#f59e0b; --mid:#fbbf24; --bad:#ef4444;
  }
  html,body{margin:0;background:var(--bg);color:var(--fg);font:15px/1.45 system-ui,Segoe UI,Roboto,Inter,Arial}
  .wrap{max-width:1000px;margin:0 auto;padding:20px}
  h1{font-size:22px;margin:0 0 12px}
  .note{color:var(--muted);margin:0 0 14px}
  .grid{display:grid;grid-template-columns:1fr 320px;gap:16px}
  @media (max-width:980px){ .grid{grid-template-columns:1fr} }
  .box{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px}
  .box h2{font-size:16px;margin:0 0 8px}
  .q{border:1px solid var(--line);border-radius:12px;padding:12px;background:#0f1629;margin-bottom:10px}
  .q h3{margin:0 0 8px;font-size:16px}
  .choices{display:grid;gap:8px}
  .choice{display:flex;gap:10px;align-items:flex-start;padding:8px;border:1px solid var(--line);border-radius:10px;background:#0b162b}
  .choice.correct{border-color:#134e4a;background:#0b1f1a}
  .choice.incorrect{border-color:#4b1e1e;background:#1a0f12}
  .choice input{margin-top:3px}
  .explain{margin-top:8px;color:#cfe0ff;font-size:13px;display:none}
  .explain.show{display:block}
  .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
  button, select{background:#0f1629;color:var(--fg);border:1px solid var(--line);border-radius:8px;padding:8px 12px;cursor:pointer}
  .pill{display:inline-block;padding:2px 8px;border:1px solid var(--line);border-radius:999px;background:#0f1629;color:#cbd6ea}
  .scoreCard{display:grid;place-items:center}
  .ring{width:220px;height:220px;display:block}
  .ring text{font:600 28px/1.1 system-ui,Segoe UI,Roboto}
  .meta{margin-top:8px;color:#cfe0ff;text-align:center}
  .legend{display:flex;gap:10px;flex-wrap:wrap;color:#9fb1d3;font-size:12px;margin-top:10px;justify-content:center}
  .legend .sw{width:14px;height:14px;border-radius:4px;border:1px solid var(--line);display:inline-block}
  .r{background:var(--bad)} .o{background:var(--warn)} .y{background:var(--mid)} .g{background:var(--good)}
</style>
</head>
<body>
<div class="wrap">
  <h1>Final Quiz — Vector Databases</h1>
  <div class="note">Answer a few questions to check your understanding. Submit to see explanations and your score ring.</div>

  <div class="grid">
    <!-- Left: Questions -->
    <div class="box">
      <h2>Questions</h2>
      <div class="controls">
        <button id="shuffle">Shuffle</button>
        <button id="reset">Reset</button>
        <span class="pill" id="progress">0 answered</span>
      </div>
      <div id="qs"></div>
      <div class="controls">
        <button id="submit">Submit</button>
        <select id="revealMode" title="When to show explanations">
          <option value="onSubmit" selected>Show explanations on submit</option>
          <option value="always">Always show explanations</option>
        </select>
      </div>
    </div>

    <!-- Right: Score ring -->
    <div class="box scoreCard">
      <h2>Score</h2>
      <svg class="ring" viewBox="0 0 120 120" aria-label="Score ring">
        <!-- background circle -->
        <circle cx="60" cy="60" r="54" fill="none" stroke="#1f2a44" stroke-width="10"/>
        <!-- progress circle -->
        <circle id="arc" cx="60" cy="60" r="54" fill="none" stroke="var(--bad)" stroke-width="10"
                stroke-linecap="round" stroke-dasharray="339.292" stroke-dashoffset="339.292" transform="rotate(-90 60 60)"/>
        <text id="scoreText" x="60" y="66" text-anchor="middle" fill="var(--bad)">0%</text>
      </svg>
      <div class="meta" id="meta">Submit answers to see your score.</div>
      <div class="legend">
        <span><span class="sw r"></span> &lt; 50%</span>
        <span><span class="sw o"></span> 50–69%</span>
        <span><span class="sw y"></span> 70–79%</span>
        <span><span class="sw g"></span> ≥ 80%</span>
      </div>
    </div>
  </div>
</div>

<script>
/* ----------------- Quiz Data ----------------- */
const QUESTIONS = [
  {
    q: "Why use a vector database instead of a regular SQL table for similarity search?",
    choices: [
      "SQL engines can’t store numbers.",
      "Vector DBs use specialized indexes (e.g., IVF/HNSW) to avoid scanning all rows.",
      "Vector DBs automatically label images with captions.",
      "Vector DBs are only for images, not text."
    ],
    correct: 1,
    explain: "Vector DBs support approximate nearest neighbor indexes (like IVF, HNSW) to skip most comparisons, which is crucial at scale."
  },
  {
    q: "What is an embedding (vector) in this context?",
    choices: [
      "A unique filename assigned to an image.",
      "A list of numbers capturing features of the data point.",
      "Any JSON object with keys and values.",
      "A lossless pixel-by-pixel copy of the input."
    ],
    correct: 1,
    explain: "Embeddings are numeric feature vectors that place items in a metric space where distances reflect similarity."
  },
  {
    q: "Feature extraction refers to:",
    choices: [
      "Deleting unused columns from a table.",
      "Detecting measurable characteristics (features) from raw data to feed into vectors.",
      "Compressing images to smaller file sizes.",
      "Reformatting data to XML."
    ],
    correct: 1,
    explain: "Feature extraction turns raw inputs into measurable attributes the model can encode numerically."
  },
  {
    q: "Cosine similarity mainly measures:",
    choices: [
      "Difference in vector lengths only.",
      "Direction alignment between vectors, ignoring magnitude when normalized.",
      "The fastest SQL query plan.",
      "Whether two strings share identical words."
    ],
    correct: 1,
    explain: "Cosine compares the angle between vectors. With L2-normalization, it emphasizes direction (semantic similarity)."
  },
  {
    q: "The 'curse of dimensionality' implies that as dimensionality increases:",
    choices: [
      "Distances tend to concentrate, making nearest neighbor harder.",
      "All algorithms get faster.",
      "Cosine similarity becomes undefined.",
      "Indexing stops working completely."
    ],
    correct: 0,
    explain: "In high-D spaces, many distances look similar, degrading discrimination and making indexing/NN search trickier."
  },
  {
    q: "Why are vectors poor candidates for primary keys?",
    choices: [
      "They cannot be serialized.",
      "Different items can yield very similar or even identical vectors (collisions).",
      "Databases can’t compare floating points.",
      "They require GPU support to store."
    ],
    correct: 1,
    explain: "Embeddings are not guaranteed unique; near-duplicates and collisions occur, so use stable IDs and store vectors as attributes."
  },
  {
    q: "Nearest neighbor (NN) vs Exact match:",
    choices: [
      "NN retrieves the single row with the smallest ID.",
      "Exact match needs the identical vector; NN returns items whose vectors are closest.",
      "NN requires full table scans; exact match does not.",
      "Exact match is only for text."
    ],
    correct: 1,
    explain: "Exact match compares equality; NN ranks by proximity under a metric (cosine, Euclidean)."
  },
  {
    q: "IVF indexing roughly works by:",
    choices: [
      "Hashing vectors to a single integer key.",
      "Clustering vectors into coarse lists and probing a few closest lists per query.",
      "Sorting vectors alphabetically.",
      "Converting vectors to images and matching pixels."
    ],
    correct: 1,
    explain: "IVF = Inverted File: partition the space with coarse centroids, then probe nearest lists instead of scanning all vectors."
  }
];

/* -------------- Render & State -------------- */
const qsEl = document.getElementById('qs');
const progressEl = document.getElementById('progress');
const submitBtn = document.getElementById('submit');
const resetBtn = document.getElementById('reset');
const shuffleBtn = document.getElementById('shuffle');
const revealMode = document.getElementById('revealMode');

let order = [...QUESTIONS.keys()];
let answers = new Map(); // idx -> choice

function render(){
  qsEl.innerHTML = '';
  order.forEach((qi, n)=>{
    const item = QUESTIONS[qi];
    const card = document.createElement('div');
    card.className='q';
    card.innerHTML = `<h3>Q${n+1}. ${item.q}</h3>`;
    const list = document.createElement('div'); list.className='choices';

    item.choices.forEach((c, idx)=>{
      const id = `q${qi}_c${idx}`;
      const row = document.createElement('label'); row.className='choice';
      row.innerHTML = `
        <input type="radio" name="q${qi}" id="${id}" value="${idx}"/>
        <div><div>${c}</div></div>
      `;
      list.appendChild(row);
    });

    const ex = document.createElement('div'); ex.className='explain'; ex.textContent = item.explain;

    card.appendChild(list);
    card.appendChild(ex);
    qsEl.appendChild(card);

    // restore selection if present
    const picked = answers.get(qi);
    if(picked !== undefined){
      const inp = card.querySelector(`input[value="${picked}"]`);
      if(inp){ inp.checked = true; }
    }

    // wire change updates
    list.addEventListener('change', (e)=>{
      if(e.target && e.target.name === `q${qi}`){
        answers.set(qi, parseInt(e.target.value,10));
        updateProgress();
        if(revealMode.value==='always'){
          showFeedback(card, qi);
        }
      }
    });

    // if revealMode=always and already answered, show feedback
    if(revealMode.value==='always' && answers.has(qi)){
      showFeedback(card, qi);
    }
  });

  updateProgress();
}

function updateProgress(){
  const count = answers.size;
  progressEl.textContent = `${count} answered`;
}

function showFeedback(card, qi){
  const picked = answers.get(qi);
  const correct = QUESTIONS[qi].correct;
  const choices = card.querySelectorAll('.choice');
  choices.forEach((ch, idx)=>{
    ch.classList.remove('correct','incorrect');
    if(picked !== undefined){
      if(idx === picked){
        ch.classList.add(idx===correct ? 'correct' : 'incorrect');
      }
    }
  });
  const ex = card.querySelector('.explain');
  ex.classList.add('show');
}

/* -------------- Score Ring -------------- */
const arc = document.getElementById('arc');
const scoreText = document.getElementById('scoreText');
const meta = document.getElementById('meta');
const CIRC = 2*Math.PI*54; // r=54

function setRing(pct){
  const clamped = Math.max(0, Math.min(100, pct));
  const off = CIRC * (1 - clamped/100);
  arc.style.strokeDasharray = CIRC.toFixed(3);
  arc.style.strokeDashoffset = off.toFixed(3);
  scoreText.textContent = `${Math.round(clamped)}%`;

  let color = 'var(--bad)';
  if(clamped >= 80) color = 'var(--good)';
  else if(clamped >= 70) color = 'var(--mid)';
  else if(clamped >= 50) color = 'var(--warn)';
  arc.style.stroke = color;
  scoreText.setAttribute('fill', color);
}

/* -------------- Handlers -------------- */
submitBtn.addEventListener('click', ()=>{
  // reveal all feedback
  [...qsEl.children].forEach((card, i)=>{
    const qi = order[i];
    showFeedback(card, qi);
  });

  const total = order.length;
  let correct = 0;
  order.forEach(qi=>{
    if(answers.get(qi) === QUESTIONS[qi].correct) correct++;
  });
  const pct = (correct/total)*100;
  animateRingTo(pct);
  meta.textContent = `You got ${correct} of ${total} correct.`;

  // focus the score for screen readers
  scoreText.setAttribute('aria-live', 'polite');
});

resetBtn.addEventListener('click', ()=>{
  answers.clear();
  setRing(0);
  scoreText.setAttribute('fill','var(--bad)'); arc.style.stroke='var(--bad)';
  meta.textContent='Submit answers to see your score.';
  render();
});

shuffleBtn.addEventListener('click', ()=>{
  // Fisher–Yates shuffle
  for(let i=order.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [order[i], order[j]] = [order[j], order[i]];
  }
  render();
});

revealMode.addEventListener('change', render);

/* ring animation */
let animId=null;
function animateRingTo(target){
  cancelAnimationFrame(animId);
  const startText = parseInt(scoreText.textContent) || 0;
  const start = performance.now();
  const dur = 600;
  function tick(t){
    const k = Math.min(1, (t-start)/dur);
    const val = startText + (target - startText)*ease(k);
    setRing(val);
    if(k<1) animId = requestAnimationFrame(tick);
  }
  animId = requestAnimationFrame(tick);
}
function ease(x){ return 1 - Math.pow(1-x, 3); }

/* -------------- Init -------------- */
render();
setRing(0);
</script>
</body>
</html>
