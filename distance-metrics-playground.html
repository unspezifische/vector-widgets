<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Distance Metrics Playground</title>
<style>
  :root{
    --bg:#0b1020; --fg:#e8ecf2; --muted:#9aa7bd; --accent:#8fd3ff;
    --line:#223252; --card:#141b2f; --grid:#1a2742;
    --a:#7dd3fc; --b:#86efac; --ab:#fca5a5; --arc:#ffd166;
  }
  html,body{margin:0;background:var(--bg);color:var(--fg);font:15px/1.45 system-ui,Segoe UI,Roboto,Inter,Arial}
  .wrap{max-width:1000px;margin:0 auto;padding:20px}
  h1{font-size:22px;margin:0 0 6px}
  .note{color:var(--muted);margin-bottom:14px}
  .panel{display:grid;grid-template-columns:1.2fr 0.8fr;gap:16px}
  @media (max-width:980px){.panel{grid-template-columns:1fr}}
  .board{position:relative;height:540px;border:1px solid var(--line);border-radius:12px;background:
    linear-gradient(0deg, transparent 49%, var(--grid) 50%, transparent 51%),
    linear-gradient(90deg, transparent 49%, var(--grid) 50%, transparent 51%);
    background-color:var(--card);overflow:hidden}
  canvas{position:absolute;inset:0}
  .dot{position:absolute;translate:-50% -50%;display:grid;place-items:center;
    width:22px;height:22px;border-radius:50%;border:2px solid var(--line);color:#0b1020;font-weight:700;cursor:grab}
  .dot:focus{outline:2px solid var(--accent);outline-offset:3px}
  .A{background:var(--a)}
  .B{background:var(--b)}
  .controls .box{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px;margin-bottom:12px}
  .controls h2{font-size:16px;margin:0 0 8px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:6px 0}
  label{color:#cbd6ea}
  select, input[type=number], button{background:#0f1629;color:var(--fg);border:1px solid var(--line);border-radius:8px;padding:8px 10px}
  input[type=checkbox]{transform:translateY(1px)}
  button{cursor:pointer}
  code{background:#0f1629;border:1px solid var(--line);border-radius:8px;padding:3px 6px}
  .formula{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#cfe0ff}
  .val{color:#e6eefc}
  .legend{display:flex;gap:12px;align-items:center;margin-top:6px;color:var(--muted)}
  .key{display:inline-flex;align-items:center;gap:6px}
  .sw{width:14px;height:14px;border-radius:4px;border:1px solid var(--line)}
  .sA{background:var(--a)} .sB{background:var(--b)} .sAB{background:var(--ab)} .sArc{background:var(--arc)}
</style>
</head>
<body>
<div class="wrap">
  <h1>Distance Metrics Playground</h1>
  <div class="note">Drag points <b>A</b> and <b>B</b>, or nudge with arrow keys when focused. Switch metrics to see different notions of “closeness.”</div>

  <div class="panel">
    <div class="board" id="board" role="application" aria-label="2D plane">
      <canvas id="grid" width="800" height="540" aria-hidden="true"></canvas>
      <canvas id="viz" width="800" height="540" aria-label="Visualization"></canvas>
      <button class="dot A" id="dotA" aria-label="Point A" title="Point A">A</button>
      <button class="dot B" id="dotB" aria-label="Point B" title="Point B">B</button>
      <div class="legend">
        <span class="key"><span class="sw sA"></span>A vector</span>
        <span class="key"><span class="sw sB"></span>B vector</span>
        <span class="key"><span class="sw sAB"></span>A→B segment</span>
        <span class="key"><span class="sw sArc"></span>Angle arc</span>
      </div>
    </div>

    <div class="controls">
      <div class="box">
        <h2>Metric & Options</h2>
        <div class="row">
          <label>Metric:
            <select id="metric">
              <option value="euclid">Euclidean distance</option>
              <option value="cosine">Cosine similarity</option>
              <option value="dot">Dot product</option>
            </select>
          </label>
          <label title="Scale each vector to unit length for the visualization">
            <input type="checkbox" id="normalize"/> Normalize vectors
          </label>
          <button id="reset">Reset</button>
        </div>
      </div>

      <div class="box">
        <h2>Coordinates</h2>
        <div class="row">
          <label>A.x <input id="ax" type="number" step="0.1" value="0.6"/></label>
          <label>A.y <input id="ay" type="number" step="0.1" value="0.3"/></label>
        </div>
        <div class="row">
          <label>B.x <input id="bx" type="number" step="0.1" value="0.2"/></label>
          <label>B.y <input id="by" type="number" step="0.1" value="0.7"/></label>
        </div>
        <div class="row">
          <button id="apply">Apply</button>
        </div>
      </div>

      <div class="box">
        <h2>Formulas & Values</h2>
        <div class="row formula" id="formula">—</div>
        <div class="row">Result: <span class="val" id="result">—</span></div>
        <div class="row">|A| = <span class="val" id="na">—</span> &nbsp; |B| = <span class="val" id="nb">—</span> &nbsp; A·B = <span class="val" id="dotval">—</span></div>
        <div class="row">θ = <span class="val" id="theta">—</span> rad (<span class="val" id="thetaDeg">—</span>°)</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ---------- Utilities ---------- */
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
function dot([ax,ay],[bx,by]){return ax*bx+ay*by;}
function norm([x,y]){return Math.hypot(x,y);}
function sub([ax,ay],[bx,by]){return [ax-bx, ay-by];}
function angleBetween(a,b){
  const na=norm(a), nb=norm(b);
  if(na===0||nb===0) return NaN;
  let c = dot(a,b)/(na*nb);
  c = Math.max(-1, Math.min(1,c)); // guard numeric drift
  return Math.acos(c);
}

/* ---------- Elements ---------- */
const board=document.getElementById('board');
const grid=document.getElementById('grid');
const viz =document.getElementById('viz');
const gctx=grid.getContext('2d');
const vctx=viz.getContext('2d');
const dotA=document.getElementById('dotA');
const dotB=document.getElementById('dotB');

const metricEl=document.getElementById('metric');
const normalizeEl=document.getElementById('normalize');
const resetEl=document.getElementById('reset');
const axEl=document.getElementById('ax'), ayEl=document.getElementById('ay');
const bxEl=document.getElementById('bx'), byEl=document.getElementById('by');
const applyEl=document.getElementById('apply');

const formulaEl=document.getElementById('formula');
const resEl=document.getElementById('result');
const naEl=document.getElementById('na');
const nbEl=document.getElementById('nb');
const dotEl=document.getElementById('dotval');
const thEl=document.getElementById('theta');
const thdEl=document.getElementById('thetaDeg');

/* ---------- Coordinate transforms (world in [0,1]x[0,1]) ---------- */
function W(){return board.clientWidth;}
function H(){return board.clientHeight;}
function w2p([x,y]){ return [x*W(), (1-y)*H()]; }
function p2w([px,py]){ return [clamp(px/W(),0,1), clamp(1-py/H(),0,1)]; }

/* ---------- State ---------- */
let A=[0.6,0.3], B=[0.2,0.7];

/* ---------- Draw grid + axes ---------- */
function drawGrid(){
  grid.width = W(); grid.height = H();
  gctx.clearRect(0,0,W(),H());
  // grid lines every 10%
  gctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid').trim();
  gctx.lineWidth=1;
  for(let i=1;i<10;i++){
    // vertical
    gctx.beginPath(); gctx.moveTo(i*W()/10,0); gctx.lineTo(i*W()/10,H()); gctx.stroke();
    // horizontal
    gctx.beginPath(); gctx.moveTo(0,i*H()/10); gctx.lineTo(W(),i*H()/10); gctx.stroke();
  }
  // axes (origin at center)
  gctx.strokeStyle="#304463"; gctx.lineWidth=1.5;
  gctx.beginPath(); gctx.moveTo(W()/2,0); gctx.lineTo(W()/2,H()); gctx.stroke();
  gctx.beginPath(); gctx.moveTo(0,H()/2); gctx.lineTo(W(),H()/2); gctx.stroke();
}

/* ---------- Drawing vectors and metrics ---------- */
function arrow(from,to,color){
  vctx.strokeStyle=color; vctx.lineWidth=3; vctx.fillStyle=color;
  vctx.beginPath(); vctx.moveTo(...from); vctx.lineTo(...to); vctx.stroke();
  // arrow head
  const dx=to[0]-from[0], dy=to[1]-from[1], len=Math.hypot(dx,dy)||1;
  const ux=dx/len, uy=dy/len;
  const size=10;
  vctx.beginPath();
  vctx.moveTo(to[0],to[1]);
  vctx.lineTo(to[0]-ux*size - uy*size*0.7, to[1]-uy*size + ux*size*0.7);
  vctx.lineTo(to[0]-ux*size + uy*size*0.7, to[1]-uy*size - ux*size*0.7);
  vctx.closePath(); vctx.fill();
}

function draw(){
  viz.width = W(); viz.height = H();
  vctx.clearRect(0,0,W(),H());

  // origin in pixel coords
  const O = w2p([0.5,0.5]);
  // vectors (optionally normalized)
  let a=A.slice(), b=B.slice();
  if(normalizeEl.checked){
    const na = norm(sub(A,[0.5,0.5])), nb=norm(sub(B,[0.5,0.5]));
    // keep direction but unit length relative to center
    const va = sub(A,[0.5,0.5]);
    const vb = sub(B,[0.5,0.5]);
    const ua = na? [va[0]/na, va[1]/na] : [0,0];
    const ub = nb? [vb[0]/nb, vb[1]/nb] : [0,0];
    // scale to 0.35 canvas span for visibility
    a = add([0.5,0.5],[ua[0]*0.35, ua[1]*0.35]);
    b = add([0.5,0.5],[ub[0]*0.35, ub[1]*0.35]);
  }

  const Ap = w2p(a), Bp = w2p(b);

  // arrows OA and OB
  arrow(O, Ap, getComputedStyle(document.documentElement).getPropertyValue('--a').trim());
  arrow(O, Bp, getComputedStyle(document.documentElement).getPropertyValue('--b').trim());

  // segment AB
  vctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--ab').trim();
  vctx.lineWidth=2.5;
  vctx.setLineDash([6,6]);
  vctx.beginPath(); vctx.moveTo(...Ap); vctx.lineTo(...Bp); vctx.stroke();
  vctx.setLineDash([]);

  // angle arc (for cosine)
  const va = [Ap[0]-O[0], Ap[1]-O[1]];
  const vb = [Bp[0]-O[0], Bp[1]-O[1]];
  const th = angleBetween([va[0],-va[1]],[vb[0],-vb[1]]); // flip y back to math coords
  if(!isNaN(th) && metricEl.value!=='euclid'){
    const ra = Math.min(80, Math.min(Math.hypot(...va), Math.hypot(...vb))*0.6);
    const a0 = Math.atan2(-va[1], va[0]);
    const a1 = Math.atan2(-vb[1], vb[0]);
    // normalize sweep
    let start=a0, end=a1;
    // pick the smaller arc
    let diff = ((end-start+Math.PI*2)%(Math.PI*2));
    if(diff>Math.PI){ let t=start; start=end; end=t; diff = ((end-start+Math.PI*2)%(Math.PI*2)); }
    vctx.beginPath();
    vctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--arc').trim();
    vctx.lineWidth=3;
    vctx.arc(O[0],O[1],ra,start,end,false);
    vctx.stroke();
  }

  // place draggable dots at actual (possibly normalized) a,b
  placeDot(dotA, a); placeDot(dotB, b);

  // update panels
  updateValues();
}

function placeDot(el, wpt){
  const [px,py]=w2p(wpt);
  el.style.left = px+'px'; el.style.top=py+'px';
}

/* ---------- UI values ---------- */
function updateValues(){
  // compute from original (non-normalized) A,B relative to origin center
  const a0 = sub(A,[0.5,0.5]), b0=sub(B,[0.5,0.5]);
  let a=a0, b=b0;
  if(normalizeEl.checked){
    const na=norm(a0), nb=norm(b0);
    a = na? [a0[0]/na, a0[1]/na] : [0,0];
    b = nb? [b0[0]/nb, b0[1]/nb] : [0,0];
  }

  const na=norm(a), nb=norm(b);
  const dp=dot(a,b);
  const eu=Math.hypot(a[0]-b[0], a[1]-b[1]);
  const cos = (na===0||nb===0)? NaN : (dp/(na*nb));
  const theta = isNaN(cos)? NaN : Math.acos(Math.max(-1,Math.min(1,cos)));

  // formula text
  const metric=metricEl.value;
  if(metric==='euclid'){
    formulaEl.innerHTML = `Euclidean: ‖A−B‖ = √((Aₓ−Bₓ)² + (Aᵧ−Bᵧ)²)`;
    resEl.textContent = eu.toFixed(4);
  }else if(metric==='cosine'){
    formulaEl.innerHTML = `Cosine: cos(θ) = (A·B) / (‖A‖‖B‖)`;
    resEl.textContent = isNaN(cos)? '—' : cos.toFixed(4);
  }else{
    formulaEl.innerHTML = `Dot product: A·B = AₓBₓ + AᵧBᵧ`;
    resEl.textContent = dp.toFixed(4);
  }

  naEl.textContent = na.toFixed(4);
  nbEl.textContent = nb.toFixed(4);
  dotEl.textContent= dp.toFixed(4);
  thEl.textContent = isNaN(theta)? '—' : theta.toFixed(4);
  thdEl.textContent= isNaN(theta)? '—' : (theta*180/Math.PI).toFixed(2);
}

/* ---------- Dragging / Keyboard ---------- */
function enableDrag(el, which){
  let dragging=false, off=[0,0];

  function onDown(e){
    dragging=true; el.style.cursor='grabbing';
    const r=el.getBoundingClientRect();
    const cx=(e.touches?e.touches[0].clientX:e.clientX);
    const cy=(e.touches?e.touches[0].clientY:e.clientY);
    off=[cx - r.left, cy - r.top];
    e.preventDefault();
    el.focus();
  }
  function onMove(e){
    if(!dragging) return;
    const bx=board.getBoundingClientRect();
    const cx=(e.touches?e.touches[0].clientX:e.clientX) - bx.left - off[0] + el.offsetWidth/2;
    const cy=(e.touches?e.touches[0].clientY:e.clientY) - bx.top  - off[1] + el.offsetHeight/2;
    const w=p2w([cx,cy]);
    if(which==='A') A=w; else B=w;
    syncInputs();
    draw();
  }
  function onUp(){ dragging=false; el.style.cursor='grab'; }

  el.addEventListener('mousedown', onDown);
  el.addEventListener('touchstart', onDown, {passive:false});
  window.addEventListener('mousemove', onMove, {passive:false});
  window.addEventListener('touchmove', onMove, {passive:false});
  window.addEventListener('mouseup', onUp);
  window.addEventListener('touchend', onUp);

  // keyboard nudges
  el.addEventListener('keydown', (e)=>{
    if(!['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) return;
    e.preventDefault();
    const step = e.shiftKey? 0.03 : 0.01;
    let P = which==='A'? A.slice(): B.slice();
    if(e.key==='ArrowLeft')  P[0]-=step;
    if(e.key==='ArrowRight') P[0]+=step;
    if(e.key==='ArrowUp')    P[1]+=step;
    if(e.key==='ArrowDown')  P[1]-=step;
    P[0]=clamp(P[0],0,1); P[1]=clamp(P[1],0,1);
    if(which==='A') A=P; else B=P;
    syncInputs();
    draw();
  });
}

function syncInputs(){
  axEl.value=A[0].toFixed(3); ayEl.value=A[1].toFixed(3);
  bxEl.value=B[0].toFixed(3); byEl.value=B[1].toFixed(3);
}

function applyInputs(){
  const ax=parseFloat(axEl.value), ay=parseFloat(ayEl.value);
  const bx=parseFloat(bxEl.value), by=parseFloat(byEl.value);
  if(Number.isFinite(ax)&&Number.isFinite(ay)) A=[clamp(ax,0,1), clamp(ay,0,1)];
  if(Number.isFinite(bx)&&Number.isFinite(by)) B=[clamp(bx,0,1), clamp(by,0,1)];
  draw();
}

/* ---------- Resize handling ---------- */
function resizeCanvases(){
  const ratio = window.devicePixelRatio||1;
  [grid,viz].forEach(cv=>{
    const rect=cv.getBoundingClientRect();
    cv.width = Math.floor(rect.width*ratio);
    cv.height= Math.floor(rect.height*ratio);
    const ctx=cv.getContext('2d');
    ctx.setTransform(ratio,0,0,ratio,0,0);
  });
  drawGrid();
  draw();
}

/* ---------- Hooks ---------- */
enableDrag(dotA,'A'); enableDrag(dotB,'B');
metricEl.addEventListener('change', draw);
normalizeEl.addEventListener('change', draw);
resetEl.addEventListener('click', ()=>{
  A=[0.6,0.3]; B=[0.2,0.7]; normalizeEl.checked=false; metricEl.value='euclid';
  syncInputs(); draw();
});
applyEl.addEventListener('click', applyInputs);
[axEl,ayEl,bxEl,byEl].forEach(el=>{
  el.addEventListener('keydown', e=>{ if(e.key==='Enter') applyInputs(); });
  el.addEventListener('change', applyInputs);
});

const ro=new ResizeObserver(resizeCanvases);
ro.observe(board);

/* ---------- Init ---------- */
syncInputs();
resizeCanvases();
</script>
</body>
</html>